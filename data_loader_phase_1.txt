@startuml Keras-Based DataLoader - Phase 1

!define KERAS #E3F2FD
!define STRATEGY #FFF3E0
!define CONFIG #F3E5F5

' ===============================================================================
' Configuration
' ===============================================================================

package "Configuration" CONFIG {
  class DatasetConfig {
    +batch_size: int
    +shuffle: bool
    +seed: Optional[int]
    --
    +to_dict(): Dict
    +from_dict(config_dict: Dict): DatasetConfig
  }
}

' ===============================================================================
' Core Abstraction (Strategy Pattern)
' ===============================================================================

package "Loading Strategy" STRATEGY {
  abstract class LoadingStrategy {
    {abstract} +load_batch(file_handle: h5py.File, indices: np.ndarray): Tuple
    {abstract} +get_sample_count(file_handle: h5py.File): int
  }
  
  note right of LoadingStrategy
    Simple 2-method interface
    Defines HOW to load data from HDF5
  end note
}

' ===============================================================================
' Concrete Strategies
' ===============================================================================

package "Phase 1 Strategies" STRATEGY {
  class BasicLoadingStrategy {
    +tokens_key: str = "tokens"
    +labels_key: str = "labels"
    --
    +load_batch(file_handle, indices): Tuple[np.ndarray, np.ndarray]
    +get_sample_count(file_handle): int
  }

  class ConditionalLoadingStrategy {
    +tokens_key: str = "tokens"
    +labels_key: str = "labels"
    +one_hot_encode: bool = True
    +num_classes: int
    --
    +load_batch(file_handle, indices): Tuple[Dict, np.ndarray]
    +get_sample_count(file_handle): int
  }

  class MultiInputLoadingStrategy {
    +tokens_key: str = "tokens"
    +drum_tokens_key: str = "drum_tokens"
    +labels_key: str = "labels"
    --
    +load_batch(file_handle, indices): Tuple[Dict, np.ndarray]
    +get_sample_count(file_handle): int
  }
}

' ===============================================================================
' Main Keras Sequence
' ===============================================================================

package "Keras Integration" KERAS {
  class "keras.utils.Sequence" as KerasSequence <<builtin>> {
    {abstract} +__len__(): int
    {abstract} +__getitem__(idx: int): Tuple
    +on_epoch_end()
  }
  
  class MusicDataSequence {
    +hdf5_path: Path
    +config: DatasetConfig
    +loading_strategy: LoadingStrategy
    -_file_handle: h5py.File
    -_total_samples: int
    -_indices: np.ndarray
    --
    +__len__(): int
    +__getitem__(idx: int): Tuple
    +on_epoch_end()
    +close()
    +__enter__()
    +__exit__()
    -_initialize()
    -_shuffle_indices()
  }
  
  note right of MusicDataSequence
    Main class - wraps HDF5 loading
    with pluggable strategies
    
    Works directly with model.fit():
      sequence = MusicDataSequence(
          hdf5_path="train.h5",
          strategy=BasicLoadingStrategy()
      )
      model.fit(sequence, epochs=10)
  end note
}

' ===============================================================================
' Relationships
' ===============================================================================

' Inheritance
KerasSequence <|-- MusicDataSequence
LoadingStrategy <|-- BasicLoadingStrategy
LoadingStrategy <|-- ConditionalLoadingStrategy
LoadingStrategy <|-- MultiInputLoadingStrategy

' Composition
MusicDataSequence *-- DatasetConfig
MusicDataSequence *-- LoadingStrategy

' ===============================================================================
' Usage Examples
' ===============================================================================

note as UsageExamples
  **Usage Examples**
  
  **1. Basic unconditional generation:**
    strategy = BasicLoadingStrategy()
    train_seq = MusicDataSequence(
        hdf5_path="data/encoded_samples/jazz_polyphonic/train.h5",
        config=DatasetConfig(batch_size=32, shuffle=True),
        loading_strategy=strategy
    )
    model.fit(train_seq, epochs=10)
  
  **2. Conditional generation (genre):**
    strategy = ConditionalLoadingStrategy(num_classes=10)
    train_seq = MusicDataSequence(
        hdf5_path="data/encoded_samples/jazz_polyphonic/train.h5",
        config=DatasetConfig(batch_size=32),
        loading_strategy=strategy
    )
    model.fit(train_seq, epochs=10)
  
  **3. Multi-input (pitched + drums):**
    strategy = MultiInputLoadingStrategy()
    train_seq = MusicDataSequence(
        hdf5_path="data/encoded_samples/jazz_polyphonic/train.h5",
        config=DatasetConfig(batch_size=32),
        loading_strategy=strategy
    )
    model.fit(train_seq, epochs=10)
  
  **4. Multiple splits:**
    train_seq = MusicDataSequence("train.h5", strategy=strategy)
    val_seq = MusicDataSequence("val.h5", strategy=strategy)
    
    model.fit(
        train_seq,
        validation_data=val_seq,
        epochs=10
    )
end note

' ===============================================================================
' Strategy Details
' ===============================================================================

note bottom of BasicLoadingStrategy
  **Returns:** (tokens, labels)
  
  tokens: [batch_size, seq_len]
  labels: [batch_size, num_labels]
  
  Simple loading for unconditional generation
end note

note bottom of ConditionalLoadingStrategy
  **Returns:** ({tokens, condition}, targets)
  
  Input dict:
    - tokens: [batch_size, seq_len]
    - condition: [batch_size, num_classes] (one-hot)
  
  targets: [batch_size, seq_len]
  
  For genre/style conditioning
end note

note bottom of MultiInputLoadingStrategy
  **Returns:** ({pitched_tokens, drum_tokens}, labels)
  
  Input dict:
    - pitched_tokens: [batch_size, seq_len]
    - drum_tokens: [batch_size, seq_len]
  
  labels: [batch_size, num_labels]
  
  For models with separate pitched/drum encoders
end note

' ===============================================================================
' Design Notes
' ===============================================================================

note as DesignNotes
  **Design Principles:**
  
  1. **Use Keras built-ins** - No reinventing the wheel
  2. **Strategy pattern** - Easy to swap loading logic
  3. **Simple & focused** - Only what Phase 1 needs
  4. **Extensible** - Add strategies as models evolve
  
  **Benefits:**
  - Works natively with model.fit()
  - Automatic multiprocessing via keras
  - Built-in validation split support
  - Simple context manager for file handling
  
  **To add new loading strategy:**
  1. Subclass LoadingStrategy
  2. Implement load_batch() and get_sample_count()
  3. Pass to MusicDataSequence
  Done!
end note

@enduml
